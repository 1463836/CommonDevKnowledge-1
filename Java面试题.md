# 面试题整理
**from[简书文章](https://www.jianshu.com/p/c70989bd5f29)**

## 一、java面试题

### （一） java基础面试知识点
* **java中==和equals和hashCode的区别**

	基本数据类型的==比较的值相等. </br>
	类的==比较的内存的地址，即是否是同一个对象，在不覆盖equals的情况下，同比较内存地址，原实现也为 == ，如String等重写了equals方法.</br>
	hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等比较是否为同一个）</br>
	1. 如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 
	2. 如果两个对象不equals，他们的hashcode有可能相等。 
	3. 如果两个对象hashcode相等，他们不一定equals。 
	4. 如果两个对象hashcode不相等，他们一定不equals。
	
* **int、char、long各占多少字节数**

	TYPE | BYTE | BIT
	------|----|-------|
	int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float | 4 byte  |32 bit
	short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char|2 byte|16 bit
	double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long|8 byte|64 bit

	
	
* **int与integer的区别**

	int 基本类型 </br>
	integer 对象 int的封装类
	
* **谈谈对java多态的理解**
	
	继承、重写、向上转型
	</br>实现多态形式：继承和接口
	
	1. 使用父类类型的引用指向子类的对象；

	2. 该引用只能调用父类中定义的方法和变量；

	3. 如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）;

* **String、StringBuffer、StringBuilder区别**
	
	String:字符串常量 不适用于经常要改变值得情况，每次改变相当于生成一个新的对象</br>
	StringBuffer:字符串变量 （线程安全）</br>
	StringBuilder:字符串变量（线程不安全） 确保单线程下可用，效率略高于StringBuffer
	
* **什么是内部类？内部类的作用**
	
	内部类可直接访问外部类的属性</br>
	Java中内部类主要分为**成员内部类**、**局部内部类**(嵌套在方法和作用域内)、**匿名内部类**（没名字，没构造方法）、**静态内部类**（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）
	
* **抽象类和接口区别**
	
	均不能被实例化</br>
	接口抽象级别高于抽象类</br>
	接口只能声明方法，抽象类既可以声明方法也可以实现方法</br>
	抽象类内可以没有抽象方法,抽象方法不能是静态以及私有的</br>
	抽象类单继承 接口多实现</br>
	接口内可含不可变常量，之前没用过。但将常量变量放在interface中违背了其作为接口的作用而存在的宗旨，也混淆了interface与类的不同价值。</br>
	
* **抽象类的意义**

	我们再开始使用的时候就是用的接口，后来实现的子类里有些子类有共同属性，或者相同的方法实现，所以提取出来一个抽象类，作为类和接口的中介。</br>
	只有抽象类没有抽象对象
	
* **抽象类是否可以没有方法和属性？**
	
	可以
	
* **泛型中extends和super的区别**

	<? super T>表示包括T在内的任何T的父类 下界通配符</br><? extends T>表示包括T在内的任何T的子类 上界通配符
	
* **父类的静态方法能否被子类重写**

	可被继承 不能被重写</br>
	静态方法从程序开始运行后就已经分配了内存,子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法。
	
* **进程和线程的区别**

	进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</br>
	进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。</br>
	一个进程内可拥有多个线程，进程可开启进程，也可开启线程。</br>
	一个线程只能属于一个进程，线程可直接使用同进程的资源,线程依赖于进程而存在。
	
* **final，finally，finalize的区别**

	final:修饰类、成员变量和成员方法，类不可被继承，成员变量不可变，成员方法不可重写</br>
	finally:与try...catch...共同使用，确保无论是否出现异常都能被调用到</br>
	finalize:

	

	
	
